## 1. 객체

+ 클래스 : 붕어빵 틀, 설계도
+ 객체 : 만들어진 붕어빵들 (슈크림 붕어빵, 팥 붕어빵, 피자 붕어빵)
+ 인스턴스 : 클래스로 부터 만들어진 객체
+ 클래스 선언 방식
```
Car car = new Car();
```
## 2. 필드

+ 객체 고유의 데이터를 저장하는 공간
+ 선언형태는 변수와 비슷하지만 엄밀히 말하면 변수는 아님

```
 //형태 : 타입 필드 = 초기값;

String str = "hello";
```

+ 초기값이 지정되지 않은 필드는 **객체 생성**시 자동으로 기본 초기값으로 설정됨(기본타입은 0, 참조타입은 null/heap 영역이 자동초기화 기능을 가지고 있기 때문)
  
## 3. 생성자
+ 객체 생성시 초기화 담당
+ 클래스 이름으로 되어있고 리턴 타입 없음
+ 우리가 아무것도 선언해주지 않으면 자동으로 실행블록이 비워진 기본생성자가 생성됨
+ 생성자는 상속에서 제외되기때문에 부모 생성자를 무조건 호출 해줘야함
+ 생성자에 매개 변수가 선언되어있다면 무조건 매개값을 넣은 생성자를 호출해줘야함 

```
// 생성자 형태
  
클래스(매개변수선언 ...){ }

// 기본 생성자 형태
  
public(접근제한자 생략가능) Car(){ }
```

### 3-1. 생성자 오버로딩
+ 매개변수를 달리하는 생성자를 여러개 선언
+ 생성자 오버로딩시 new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자 결정
+ **Q)반드시 호출해줘야하는 이유가 뭘까?**
+ **A)자바는 객체가 생성 되어야 값이 초기화되는데 디폴트 생성자는 그냥 초기화가 되지만 생성자가 여러개이고 매개값이 명시되어있을 경우 어떤 값으로 초기화해줘야할지 몰라서 오류가 뜨는것**
+ **결론은 그냥 객체생성시 자동초기화가 필요하기 때문에 사용하는거라 아무거나 하나만 있으면 된다**

```
Car car = new Car("소나타");

Car car = new Car("소나타","흰색");

Car car = new Car("소나타","흰색",300);
```

## 4. this(자신)의 사용
+ 필드 이름과 생성자의 매개변수 이름이 같을 경우 필드임을 명시하기 위해 사용 (인스턴스의 필드에 접근하기 위해 사용)
+ **this 는 내부에서 인스턴스 멤버에 접근하기 위해 사용**

```
public class A{
    int a;
    int b;

  public A(int a, int b){
    this.a = a;
    this.b = b;
}
}
```

## 4-1. this로 다른 생성자 호출하기

```
public class A(){
//멤버 변수 선언
  String model;
  String color;
  int speed;

//생성자 오버로딩
public A(String model){
  this(model,"빨강", 300); // 맨 밑에 생성자 호출! 매개값으로 model만 받아오니 다른 값들은 설정해주면 됨!    
  }
public A(String model, String color){
   this(model, color, 250); 
  }
public A(String model, String color, int speed){
  this.model = model;
  this.color = color;
  this.speed= speed;
  }
}
```

## 4. 메소드

+ 객체의 동작을 설정
+ 메소드 안에서 선언된 변수는 메소드 안에서만 존재
+ 접근제한자, 리턴타입, 메소드 이름으로 이루어짐

### 4-1. 리턴타입

+ 메소드 선언부에 리턴타입이 있는 메소드는 반드시 리턴문으로 return값을 지정해줘야함
+ void : 리턴값이 없는 메서드
+ 리턴값이 없어도 return문 사용가능 - 이때 return은 메소드 실행을 강제 종료 시키는 역할을 함
+ return 문을 사용할때도 형변환이 가능함
  
```
public int ex1(byte x, byte y){

 byte result = x+y;
 return result;

}(byte -> int로 형변환)
```


### 4-2. 메소드 오버로딩 (강의 필요) 

+ 같은 이름의 메소드를 여러개 선언 하는것
+ 매개변수의 타입, 개수, 순서중 하나가 달라야함 (타.개.순 만 기억하자)
+ 메소드의 리턴타입은 상관없음

# 5. 정적멤버와 static (내 기준 중요하다고 생각되는 개념)

+ 정적 멤버 : 객체를 생성하지 않고 사용할 수 있는 필드와 메소드
+ 정적멤버선언 기준 : 공용데이터라면 static으로 선언하는것이 편하다 (PI)
+ 정적메소드 선언 기준 : 인스턴스 필드를 포함하지 않는다면 정적선언 (객체를 생성해주면 정적 메소드 내에서도 인스턴스 변수 사용가능) 

```
//static 선언 방식

public class Car{
  
static 타입 필드 = 초기값 ;
 
static 리턴타입 메소드(매개변수 선언){}}
```

```
//매개값만 가지고 연산하는 경우에는 값이 메소드 안에서 결과값이 변할리없기 때문에 정적 메소드로 선언하는것이 좋다

public class Calculator(){

    static int plus(int x, inty){..}

}
```

### 5-1. 정적 멤버 사용

+ **클래스 이름과 함께 도트(.) 연산자 사용**
+ 클래스 로딩과 동시에 메모리에 할당되기 때문에 객체마다 Static에 대한 정보를 가지고 있으므로 객체 없이 클래스 이름으로 사용이 가능하다
+ 정적 메소드 선언시 메서드 내부에 인스턴스 필드나 메서드 선언 불가능
+ 자신의 필드를 참조하는 this도 사용불가능
+ (객체가 생성되어야 멤버변수가 초기화 되고 static내에서 사용할 수 있다. 그래서 객체를 생성하지 않으면 자신의 변수를 가져올 수 없다.
+ 그래서 값의 초기화를 위해 객체를 생성하면 굳이 this로 접근할 필요없이 객체로 접근 가능하다) 

```
클래스.필드;

클래스.메소드(매개값,..);
```

## 6. 접근 제한자

+ **public** : 외부 클래스에서 자유롭게 사용 가능
+ **protected** : 같은 패키지 또는 자식클래스에서 사용 가능
+ **private** : 외부에서 사용 불가능
+ **default** : 같은 패키지내에 클래스만 사용가능, 접근제한자 생략시 default

## 7.Gatter와 Setter 메소드

+ 외부에서 객체의 필드로 직접적으로 접근하는것을 막기위해 사용
+ 때문에 메소드를 이용해 필드를 변경하는 방법을 사용
+ Setter : 외부에서 값 변경
+ Getter : 외부에서 값 읽음
+ 필드 타입이 boolean 일 경우 Getter은 get 이 아니라 is로 시작(isSpeed)

```
//Setter 사용 예시

void setSpeed(double speed){
  if(speed<0){  
    this.speed = 0;
    return; //speed 값이 음수면 필드의 speed를 0으로 변경
}else
  this.speed = speed
}

//Getter 사용 예시

double getSpeed(){
    double km = speed*1.6;
    return km; //km로 변환한 값을 return 하여 외부에서 값을 읽을 수 있음
}
```

