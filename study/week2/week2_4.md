## 인터페이스와 추상클래스의 차이
+ 추상클래스 : 기본적으로 클래스이며 이것을 상속, 확장하여 사용하기 위함
+ 인터페이스 : 해당 인터페이스를 구현한 객체들의 동일한 사용방법과 동작을 보장

## 1. 인터페이스

+ 추상클래스와 비슷하게 '규격' 들을 정의해 놓았기 때문에 실체가 없어 객체를 생성할 수 없음
+ 추상클래스보다 높은 개념의 설계도이기 때문에(규격정의) 생성자를 가질 수 없음
+ 기본적으로 외부에서 접근이 가능해야 하기때문에 전부 public 의 특성을 가짐(생략해도 컴파일 과정에서 붙음)

```
// 인터페이스 선언 방식

interface A{  // class 대신 interface 사용 
  타입 상수이름 = 값;
  타입 메소드 이름(매개변수); 
}

public interface AB{
  public double PI = 3.14; //인터페이스의 필드는 public static final 특성을가짐 - 상수이름은 대문자 작성

  public void turnOn(); //메소드 선언부만 작성, 추상클래스와 동일함 - 추상 메서드(기본적으로 abstract 이기 때문에 생략 가능)
}

```

### 1-1. 상수 필드 선언
+ **인터페이스는 객체 사용방법을 정의한 것이므로 모든 필드는 static final을 사용**
+ static을 사용하는 이유 : 규격이기때문에 일관된 값을 유지하기 위해서( cf> static은 한곳에서 값을 변경하면 모든 객체의 static값이 변경됨)
+ final을 사용하는 이유 : 값을 절대 변경하지 않기 위해서
+ final static은 생략가능하고 생략 하더라도 그 특성이 유지(컴파일 과정에서 자동으로 붙음)
+ 상수필드 이름은 대문자로 설정하는 것이 약속

```
public interface A{
  (public static final) String NAME = "안녕";
}

```

### 1-2. 추상메소드 선언
+ 인터페이스는 규격이기 때문에 실행 블록이 필요없는 추상 메소드로 선언
+ 인터페이스의 메소드는 모두 추상 메소드 이기때문에 public abstract 의 특성을 가짐(생략하더라도 컴파일 과정에서 자동으로 붙음)

```
public interface A{
  public int MY_NUM = 1;

public void turn(); //추상 메소드 선언
public void turnoff(); // 추상 메소드 선언
}
```

## 2. 구현클래스
+ 코드에서 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출
+ 이때 객체는 인터페이스에서 정의된 추상메소드의 실체메소드를 가지고 있어야함
+ 이러한 객체를 인터페이스의 구현 객체 라 하고 구현 객체를 생성하는 클래스를 구현 클래스라고 함 
+ 구현클래스에는 추상메소드 들에 대한 실체메소드들을 가지고 있어야함
+ implements 키워드 사용

```
// 구현 객체를 생성기 위한 구현 클래스 선언

public class A implements Animal{

}

------------------------------------------------------------------------------------------
// 인터 페이스 사용 방법
// 인터페이스 변수 animal 선언
// 선언된 인터페이스 변수에 구현 객체 대입

public class AExample{
  public static void main(String[] args){
      Animal animal;  //인터페이스 변수 선언
  animal = new A(); // 구현 객체 대입 - 자동 타입 변환 인가..?
  }
}
 
```

### 2-1. 다중인터페이스 구현 클래스
+ 다중인터페이스 선언시 모든 인터페이스에 대한 추상 메소드를 작성 해야함

```
// 다중 인터페이스 선언 방식

public class A implements Animal, Human{
  // 클래스 Animal에 대한 실체 메소드 선언
  // 클래스 Human에 대한 실체 메소드 선언
}

```

## 3. 인터페이스의 타입변환과 다형성
+ 인터페이스의 다형성 : 소스코드는 변함이 없고 구현 객체를 교체함으로써 결과가 다양해짐

```
// 인터페이스 변수 =  구현 객체;

Animal animal = new A();

------------------------------------------------------------------------------------------


public class Car{
    Tire fLTire = new HankookTire();
    Tire fRTire = new HankookTire();
    Tire bLTire = new HankookTire();
    Tire bRTire = new HankookTire();

}

```





+ Q 왜 인터페이스에는 생성자가 없고 추상클래스에는 생성자가 있을까
+ A) 추상클래스는 클래스를 확장 및 상속하기 위해 사용하는 클래스로 일반 메소드와 다를게 없다 확장은 곧 상속 이기때문에 상속을 위해서는 생성자가 무조건 필요하다 
+ 인터페이스는 말 그대로 규격을 정의해 놓은것이기 때문에 객체를 생성할 필요 없이 구현객체들로만 구현이 이루어진다 따라서 객체 생성은 구현 클래스에서 이루어지므로 인터페이스에서 생성자는 필요하지 않다 .
