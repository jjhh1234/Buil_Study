## 1. 상속

+ 클래스 재사용으로 새로운 클래스를 만들기 위해 사용
+ **단 하나의 부모클래스** 만 상속 가능(부모가 여러명일 순 없음)
+ **부모클래스에서 private 접근 제한자를 갖는 필드나 메서드는 상속 대상에서 제외**

```
class 자식클래스 extends 부모클래스{

}
```

## 2. 부모 생성자 호출

+ 자식클래스에 생성자가 명시적으로 선언되지 않았을 경우 기본 생성자에서 자동으로 부모 생성자 호출
+ **생성자는 상속이 되지 않기 때문에 부모의 필드를 이용하기 위해서는 부모 생성자 호출로 값을 초기화 시켜줘야함**
+ **자식클래스 생성자 첫줄**에 위치
+ **super 키워드로 부모 메소드나 생성자 호출 가능**

```
//자동으로 생성된 자식클래스의 기본 생성자

public CellPhone(){
  super(); //부모의 기본 생성자 호출
  }
```

```
//부모생성자가 명시적으로 선언되어있을 경우(값의 초기화를 위해 무조건 매개값을 입력해주어야함)

//명시적으로 선언한 생성자

  CellPhone(매개변수 선언){
    super(매개값.. ); //부모생성자중 매개값의 타입과 일치하는 생성자 호출
  }
```

## 3. 상속 받은 메소드 재정의(오버라이딩)

+ 부모클래스의 메소드를 자식클래스에서 다시 재정의
+ 부모메소드와 동일한 시그니처사용(리턴타입,메소드이름, 매개변수목록) - **그냥 실행부분 말곤 똑같아야함**
+ 자식클래스에서 메소드가 재정의되면 메소드 호출시 재정의된 메소드 호출됨
+ 자식클래스에서 메소드 재정의 후 부모메소드를 호출하고 싶은 경우
+ **주의) final 클래스나 메소드는 부모가 될 수 없어 클래스 상속 및 메소드 오버라이딩 불가능 - 해당선언이 최종적이기 때문에 변경을 허락하지 않음 **


```
super.부모메소드(); 
```

## 4. final class와 final메소드 
+ final 키워드 사용
+ **클래스, 필드, 메소드를 선언할 때 사용 가능**
+ **해당 선언이 최종 선언이고 절대 수정될 수 없음을 의미**
+ ** final 클래스는 상속이 불가능하기 때문에 부모클래스가 될 수 없고, 자식클래스도 만들 수 없음 (단 부모클래스를 가질 순 있음)**
+ **부모 클래스에 final 메소드가 존재하는 경우 메소드 오버라이딩도 불가(final 클래스가 아닌 경우에 final 메소드나 변수는 상속은 가능하지만 오버라이딩이나 변수의 값을 변경할 수는 없음)**

```
//final 클래스 선언(상속 불가, 변경 불가, 확장의 끝을 의미, 상속을 받을 수는 있음)

public final class A{ //final 클래스 선언

} 

//final 변수나 final 메소드는 상속은 가능하지만 오버라이딩이나 변수의 값은 변경 불가능 

final int A = 1; //final 변수 선언
public final void method(){ //final 메소드 선언

}
```

+ Q) final 클래스가 부모클래스를 가질 수 있다면 하나의 부모클래스에 자식클래스가 여러개 있고 모두 같은 메소드를 오버라이딩 하고 있다고 치자 그중 하나의 자식클래스가 final 클래스라면 거기에서 오버라이딩된 메소드는 어떻게 되는거지?
+ A) 하나의 final 클래스에서 오버라이딩 됐다고 해도 일반 클래스들에서 오버라이딩된것들은 그냥 사용이 가능하다. 다만 final을 쓴다는것은 부모클래스의 메소드의 오버라이딩을 이제 막겠다는 것이 아니라 final 클래스에서 오버라이딩 된 것들은 이제 상속을 막고 그대로 사용하겠다는 의미 

## 5. 타입변환(보충설명 사진)

+ 자동타입변환 : 프로그램 실행도중 자동적으로 일어나는 타입변환
+ 자식은 부모 타입으로 자동타입변환이 가능

```
Cat cat = new Cat(); //cat 객체 생성

Animal animal = cat;

// cat의 참조값이 animal 로 들어가면서 animal은 cat을 참조하게됨, 결국 animal = cat 이 되는것이고 animal이 cat을 참조하기 때문에 cat에만 존재하는 객체나 메소드는 사용할 수 없고, cat과 animal에 둘다 존재하는 객체나 메소드만 사용가능(cat 이 animal 에서상속 받은것)

//Cat 객체를 만들어서 객체를 Animal 타입 부모클래스로 자동타입 변환
//자식클래스객체(cat)와 부모클래스객체(animal) 둘다 사용가능 = 부모, 자식 클래스 둘다 접근가능 (객체의 이름이 존재하기 때문)
----------------------------------------------------------------------------------------------------------------------------------

Animal animal = new Cat();
//Cat객체 생성과 동시에 Animal로 타입변환
// 부모클래스 객체(animal) 만 사용가능 = 부모클래스에만 접근 가능 (cat 객체의 이름이 없기 때문)

```

### 5-1. 메소드 내 매개변수에서 일어나는 타입 변환 

```
//메소드 내 매개변수 안에서 일어나는 자동 타입 변환

public class Driver{
  void drive(Vehicle vehicle){ // 매개변수의 자동타입변환을 알아보기위해 매개변수를 가진 함수 생성
    vehicle.run(); // Vehicle  객체 안에 함수 run() 호출
  }
}

Q) 객체생성없이 바로 넣을 수 있는 이유?
A) 매개변수로 외부에서 객체를 가져오기 때문

--------------------------------------------------------------------------------------------------------
// 상위 부모 클래스 Vehicle 클래스 선언

public class Vehicle{
  public void run(){ // 실행할메소드 선언
    System.ouy.println("차량이 달립니다");
  }
}

---------------------------------------------------------------------------------------------------------
// Vehicle의 자식클래스 Bus 클래스 선언

public class Bus extends Vehicle{
  @Override //메소드 오버라이딩 
  public void run(){
    System.out.println("버스가 달립니다.");  
  }
}

---------------------------------------------------------------------------------------------------------
// Vehicle의 자식클래스 Texi 클래스 선언

public class Texi extends Vehicle{
  @Override // 메소드 오버라이딩
  public void run(){
    System.out.println("택시가 달립니다.");
  }
}

---------------------------------------------------------------------------------------------------------
public class Example{
public static void main(String[] args){
  Driver user = new Driver();
  Bus bus = new Bus();
  Texi texi = new Texi();


  user.driver(bus); //bus 객체가 vehicle로 자동 타입변환 되면서 오버라이딩된 메소드 사용됨
  user.driver(texi); // texi 객체가 vehicle로 자동 타입 변환 되면서 오버라이딩 된 메소드 사용됨 
  }
}
```

### 내가 클래스의 타입변환이 헷갈렸던 이유

+ 나는 기본타입 변환에서 int형이 double형으로 변환 가능한것 처럼 부모클래스(상위개념)의 참조값을 자식클래스(하위개념)이 가진다라고 생각함
+ 근데 Animal animal = new Cat(); 에서 animal은 결국 cat객체의 참조값을 가지게 되고 이는 Cat객체를 참조하는것이 된다
+ 이때 Cat을 참조하여도 문제가 없는이유는 Cat 객체는 Animal을 상속하고 있기 때문에 animal의 필드, 생성자, 메서드를 전부 가지고있다
+ 그럼 결국 Cat = Animal 이 성립하기 떄문에 우리는 Cat을 Animal과 동일한 타입으로 볼 수 있다.
+ cat이 animal 타입으로 바뀌므로 animal 타입 안에 선언된 클래스와 객체들만 사용 가능(오버라이딩은 예외)
+ 이것이 클래스의 자동 타입 변환이다.


+ Q) 그럼 결국 부모 클래스가 자식 클래스를 참조하게 되는것인데 왜 자식클래스에만 존재하는 필드는 사용이 안돼?
+ A)**부모는 자식을 참조하지만 자식클래스의 타입이 부모타입으로 바뀌면서 부모타입에 선언된 필드와 메소드에만 접근 가능** 
+ 예외가 있다면 타입변환 이후에도 오버라이딩된 메소드는 오버라이딩된 메소드로 호출이 된다는것(자식 클래스에서 재정의 된거라 그냥 이게 규칙임)

## 5-2. 타입변환2
+ 바로위의 부모가 아니더라도 상속계층에서 상위 타입이라면 자동으로 타입 변환 가능

 ![image](https://github.com/jjhh1234/Buil_Study/assets/105401500/fddd43cc-6baa-4ef4-a81f-234a232d64db)


## 5-3. 강제타입변환
+ 부모타입을 자식타입으로 변환하는것
+ 자식타입이 부모타입으로 자동타입변환후 자식타입으로 다시 변환할때 강제 형변환 사용
+ (Q. 상속관계인데 굳이 자식타입으로 형변환을 하려는 이유는? A.자식타입의 메소드와 필드를 사용하기 위해서)
```
Parent parent = new Child(); //부모클래스로 자동형변환

Child child = (Child) parent; //자식객체를 생성한 후 자식타입으로 강제 형변환 (참조값을 담아야 형변환이 가능하니 자식객체를 만들어서 형변환)
```
